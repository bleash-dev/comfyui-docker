name: Build and Deploy ComfyUI Docker Image

on:
  push:
    branches: [ main, dev]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  IMAGE_NAME: comfyui-docker
  PUBLIC_REGISTRY_ALIAS: p1c2v8t9  # Update this to your ECR public registry alias

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: "prod"

    permissions:
      id-token: write
      contents: read

    outputs:
      image-uri: ${{ steps.build.outputs.image-uri }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.GH_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Amazon ECR Public
      uses: docker/login-action@v3
      with:
        registry: public.ecr.aws

    - name: Create ECR repository if it doesn't exist
      run: |
        echo "ðŸ” Checking if ECR repository exists..."
        REPO_NAME="${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}"
        echo "Repository name: $REPO_NAME"
        
        # First, verify we can access ECR
        echo "ðŸ” Testing ECR access..."
        aws ecr-public describe-registries --region us-east-1 || {
          echo "âŒ Cannot access ECR public registries. Check AWS credentials and permissions."
          exit 1
        }
        
        # Check if repository exists
        if ! aws ecr-public describe-repositories --repository-names "$REPO_NAME" --region us-east-1 >/dev/null 2>&1; then
          echo "ðŸ“ Creating ECR Public repository: $REPO_NAME"
          aws ecr-public create-repository \
            --repository-name "$REPO_NAME" \
            --region us-east-1
          
          echo "âœ… Repository created successfully"
          
          # Verify the repository was created
          aws ecr-public describe-repositories --repository-names "$REPO_NAME" --region us-east-1
        else
          echo "âœ… ECR repository already exists: $REPO_NAME"
        fi

    - name: Extract Docker metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          public.ecr.aws/${{ env.PUBLIC_REGISTRY_ALIAS }}/${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}
        tags: |
          type=sha,prefix=${{ github.ref_name }}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=dev-latest,enable=${{ github.ref == 'refs/heads/dev' }}

    - name: Build and push Docker image to ECR Public
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          PYTHON_VERSION=3.10
          PYTORCH_VERSION=2.4.0
          COMFYUI_VERSION=master
        outputs: |
          type=image,name=target
          
    - name: Set image URI output
      id: image-uri
      run: |
        REPO_NAME="${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}"
        TAG="${{ github.ref == 'refs/heads/main' && 'latest' || 'dev-latest' }}"
        IMAGE_URI="public.ecr.aws/${{ env.PUBLIC_REGISTRY_ALIAS }}/${REPO_NAME}:${TAG}"
        echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Image URI: ${IMAGE_URI}"

  create-ami:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: "prod"
    if: github.event_name != 'pull_request'

    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.GH_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get latest Ubuntu AMI
      id: ubuntu-ami
      run: |
        AMI_ID=$(aws ec2 describe-images \
        --owners 099720109477 \
        --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*" \
            "Name=state,Values=available" \
        --query "Images | sort_by(@, &CreationDate) | [-1].ImageId" \
        --output text \
        --region us-east-1)
        echo "ami-id=$AMI_ID" >> $GITHUB_OUTPUT
        echo "ðŸ–¥ï¸ Base Ubuntu AMI: $AMI_ID"

    - name: Upload scripts to S3
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        S3_PREFIX="s3://viral-comm-api-ec2-deployments-dev/comfy-docker/${ENVIRONMENT}"
        
        echo "ðŸ“¤ Uploading scripts to S3..."
        echo "S3 path: ${S3_PREFIX}"
        
        # Upload preparation scripts
        aws s3 cp scripts/prepare_ami.sh "${S3_PREFIX}/prepare_ami.sh" --region ${{ env.AWS_REGION }}
        aws s3 cp scripts/setup_cloudwatch.sh "${S3_PREFIX}/setup_cloudwatch.sh" --region ${{ env.AWS_REGION }}
        
        echo "âœ… Scripts uploaded to S3"

    - name: Launch EC2 instance for AMI creation
      id: launch-instance
      timeout-minutes: 5
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        INSTANCE_NAME="comfyui-ami-builder-${ENVIRONMENT}-$(date +%Y%m%d-%H%M%S)"
        
        echo "ðŸš€ Launching EC2 instance for AMI creation..."
        echo "Environment: $ENVIRONMENT"
        echo "Instance name: $INSTANCE_NAME"
        
        # Create user data script
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        S3_PREFIX="s3://viral-comm-api-ec2-deployments-dev/comfy-docker/${ENVIRONMENT}"
        
        cat > user-data.sh << EOF
        #!/bin/bash
        set -e
        
        # Set environment variables
        export DEBIAN_FRONTEND=noninteractive
        
        # Log everything
        exec > >(tee /var/log/user-data.log) 2>&1
        echo "Starting AMI preparation at \$(date)"
        
        # Update system
        apt-get update -y
        
        # Install required packages
        apt-get install -y awscli curl wget jq
        
        # Download scripts from S3
        echo "Downloading scripts from S3..."
        mkdir -p /scripts
        cd /scripts
        
        # Download prepare_ami.sh
        aws s3 cp "${S3_PREFIX}/prepare_ami.sh" prepare_ami.sh --region ${{ env.AWS_REGION }}
        chmod +x prepare_ami.sh
        
        # Download setup_cloudwatch.sh  
        aws s3 cp "${S3_PREFIX}/setup_cloudwatch.sh" setup_cloudwatch.sh --region ${{ env.AWS_REGION }}
        chmod +x setup_cloudwatch.sh
        
        # Run the AMI preparation
        echo "Starting AMI preparation script..."
        
        # Pass Docker image as parameter to ensure it's available
        DOCKER_IMAGE="${{ needs.build-and-push.outputs.image-uri }}"
        echo "Using Docker image: \$DOCKER_IMAGE"
        
        # Run with timeout to prevent infinite hangs
        timeout 1800 /scripts/prepare_ami.sh "\$DOCKER_IMAGE" || {
            echo "âŒ AMI preparation script timed out or failed"
            echo "Exit code: $?"
            echo "Last checkpoint:"
            cat /tmp/ami_progress.txt 2>/dev/null || echo "No progress file found"
            exit 1
        }
        
        # Signal completion
        echo "AMI_PREPARATION_COMPLETE" > /tmp/ami_ready.txt
        echo "AMI preparation completed at \$(date)"
        EOF
        
        # Get available VPC and subnet
        echo "ðŸ” Finding available VPC and subnet..."
        VPC_ID=$(aws ec2 describe-vpcs \
          --filters "Name=is-default,Values=true" \
          --query 'Vpcs[0].VpcId' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
        
        if [[ -z "$VPC_ID" || "$VPC_ID" == "None" ]]; then
          echo "No default VPC found, using any available VPC..."
          VPC_ID=$(aws ec2 describe-vpcs \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
        fi
        
        SUBNET_ID=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=${VPC_ID}" \
          --query 'Subnets[0].SubnetId' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "Using VPC: $VPC_ID"
        echo "Using Subnet: $SUBNET_ID"
        
        # Create IAM role for EC2 instance to access S3
        echo "ðŸ” Creating IAM role for EC2 instance..."
        ROLE_NAME="comfyui-ami-builder-role-$(date +%s)"
        
        # Create trust policy
        cat > trust-policy.json << 'TRUST_EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        TRUST_EOF
        
        # Create IAM role
        aws iam create-role \
          --role-name "$ROLE_NAME" \
          --assume-role-policy-document file://trust-policy.json \
          --region ${{ env.AWS_REGION }}
        
        # Attach S3 read-only policy
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess" \
          --region ${{ env.AWS_REGION }}
        
        # Attach SSM policy for status checking
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore" \
          --region ${{ env.AWS_REGION }}
        
        # Attach CloudWatch logs policy for debugging
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/CloudWatchLogsFullAccess" \
          --region ${{ env.AWS_REGION }}
        
        # Create instance profile
        aws iam create-instance-profile \
          --instance-profile-name "$ROLE_NAME" \
          --region ${{ env.AWS_REGION }}
        
        # Add role to instance profile
        aws iam add-role-to-instance-profile \
          --instance-profile-name "$ROLE_NAME" \
          --role-name "$ROLE_NAME" \
          --region ${{ env.AWS_REGION }}
        
        # Wait a moment for IAM to propagate
        sleep 15
        
        echo "âœ… IAM role created: $ROLE_NAME"
        
        # Launch instance with VPC configuration and IAM role
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id ${{ steps.ubuntu-ami.outputs.ami-id }} \
          --instance-type t3.large \
          --subnet-id $SUBNET_ID \
          --associate-public-ip-address \
          --iam-instance-profile Name="$ROLE_NAME" \
          --user-data file://user-data.sh \
          --region ${{ env.AWS_REGION }} \
          --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_NAME}},{Key=Environment,Value=${ENVIRONMENT}},{Key=Purpose,Value=AMI-Builder},{Key=AutoTerminate,Value=true},{Key=IAMRole,Value=${ROLE_NAME}}]" \
          --query 'Instances[0].InstanceId' \
          --output text)
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "iam-role=$ROLE_NAME" >> $GITHUB_OUTPUT
        
        # Get the public IP for network testing
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "ðŸš€ Launched instance: $INSTANCE_ID"
        echo "ðŸŒ Public IP: $PUBLIC_IP"
        echo "âš ï¸ Instance will be automatically terminated after AMI creation"
        echo "ðŸ’¡ Using VPC: $VPC_ID, Subnet: $SUBNET_ID, IAM Role: $ROLE_NAME"

    - name: Wait for instance setup completion
      timeout-minutes: 10
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        echo "â³ Waiting for instance setup to complete..."
        
        # Wait for instance to be running
        echo "ðŸ”„ Waiting for instance to be running..."
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        echo "âœ… Instance is running"
        
        # Wait for SSM agent to be ready
        echo "ðŸ”„ Waiting for SSM agent to be ready..."
        for i in {1..10}; do
          if aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --region ${{ env.AWS_REGION }} \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text 2>/dev/null | grep -q "Online"; then
            echo "âœ… SSM agent is online"
            break
          fi
          echo "â³ SSM agent not ready yet, waiting... (attempt $i/10)"
          sleep 30
        done

    - name: Wait for AMI preparation completion
      timeout-minutes: 25
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        
        # Wait for AMI preparation to complete (check for completion file)
        echo "ðŸ”§ Monitoring AMI preparation progress..."
        for i in {1..30}; do
          echo "ðŸ” Checking AMI preparation status... (attempt $i/30)"
          
          # Check current progress
          PROGRESS_CHECK_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo === Progress Check ===",
              "if [ -f /tmp/ami_progress.txt ]; then",
              "  echo CURRENT_PROGRESS: $(cat /tmp/ami_progress.txt)",
              "else",
              "  echo CURRENT_PROGRESS: UNKNOWN",
              "fi",
              "echo === Completion Check ===",
              "test -f /tmp/ami_ready.txt && echo READY || echo NOT_READY",
              "echo === Process Check ===",
              "ps aux | grep prepare_ami.sh | grep -v grep || echo NO_PROCESS_RUNNING"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$PROGRESS_CHECK_ID" ]; then
            sleep 5
            
            RESULT=$(aws ssm get-command-invocation \
              --command-id $PROGRESS_CHECK_ID \
              --instance-id $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "PENDING")
            
            echo "Progress Status:"
            echo "$RESULT"
            
            if [[ "$RESULT" == *"READY"* ]]; then
              echo "âœ… AMI preparation completed!"
              break
            fi
            
            # Extract current progress for better monitoring
            if [[ "$RESULT" == *"CURRENT_PROGRESS:"* ]]; then
              CURRENT_STEP=$(echo "$RESULT" | grep "CURRENT_PROGRESS:" | cut -d: -f2 | xargs)
              echo "ðŸ“ Current step: $CURRENT_STEP"
            fi
            
            # Check if process is still running
            if [[ "$RESULT" == *"NO_PROCESS_RUNNING"* ]]; then
              echo "âš ï¸ AMI preparation process is not running - may have failed"
            fi
          fi
          
          if [ $i -eq 30 ]; then
            echo "âŒ Timeout waiting for AMI preparation"
            echo "ðŸ” Checking instance logs for debugging..."
            
            # Get last 50 lines of user-data log
            LOG_COMMAND_ID=$(aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["tail -50 /var/log/user-data.log || echo No user-data log found"]' \
              --region ${{ env.AWS_REGION }} \
              --query 'Command.CommandId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$LOG_COMMAND_ID" ]; then
              sleep 10
              aws ssm get-command-invocation \
                --command-id $LOG_COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --region ${{ env.AWS_REGION }} \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null || echo "Could not retrieve logs"
            fi
            
            exit 1
          fi
          
          sleep 15
        done

    - name: Verify ComfyUI setup
      timeout-minutes: 5
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        echo "ðŸ” Verifying ComfyUI setup and health..."
        
        # Check if Docker is running
        echo "ðŸ³ Checking Docker status..."
        DOCKER_CHECK_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo === Docker Service Status ===",
            "systemctl is-active docker && echo DOCKER_SERVICE_ACTIVE || echo DOCKER_SERVICE_INACTIVE",
            "systemctl status docker --no-pager -l",
            "echo === Docker Version Check ===",
            "docker version || echo DOCKER_VERSION_FAILED",
            "echo === Docker Info ===",
            "docker info || echo DOCKER_INFO_FAILED",
            "echo === Docker Images ===",
            "docker images || echo DOCKER_IMAGES_FAILED",
            "echo === Final Status ===",
            "if systemctl is-active docker >/dev/null 2>&1 && docker version >/dev/null 2>&1; then echo DOCKER_OK; else echo DOCKER_FAIL; fi"
          ]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 15
        DOCKER_STATUS=$(aws ssm get-command-invocation \
          --command-id $DOCKER_CHECK_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "Docker Status Details:"
        echo "$DOCKER_STATUS"
        
        if [[ "$DOCKER_STATUS" != *"DOCKER_OK"* ]]; then
          echo "âŒ Docker is not running properly"
          
          # Get additional debugging info
          echo "ðŸ” Getting additional debugging information..."
          DEBUG_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo === AMI Preparation Log ===",
              "tail -50 /var/log/ami-preparation.log 2>/dev/null || echo No AMI preparation log found",
              "echo === User Data Log ===", 
              "tail -50 /var/log/user-data.log 2>/dev/null || echo No user data log found",
              "echo === Docker Service Logs ===",
              "journalctl -u docker --no-pager -n 20 || echo No Docker logs found",
              "echo === System Status ===",
              "df -h",
              "free -m",
              "ps aux | grep docker"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)
          
          sleep 10
          DEBUG_INFO=$(aws ssm get-command-invocation \
            --command-id $DEBUG_ID \
            --instance-id $INSTANCE_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text)
          
          echo "Debug Information:"
          echo "$DEBUG_INFO"
          
          exit 1
        fi
        echo "âœ… Docker is running"
        
        # Check if ComfyUI Docker image is available
        echo "ðŸ–¼ï¸ Checking ComfyUI Docker image..."
        IMAGE_CHECK_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["docker images | grep comfyui && echo IMAGE_OK || echo IMAGE_FAIL"]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 10
        IMAGE_STATUS=$(aws ssm get-command-invocation \
          --command-id $IMAGE_CHECK_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        if [[ "$IMAGE_STATUS" != *"IMAGE_OK"* ]]; then
          echo "âŒ ComfyUI Docker image not found"
          exit 1
        fi
        echo "âœ… ComfyUI Docker image is available"
        
        # Test ComfyUI container functionality (without leaving it running)
        echo "ðŸ§ª Testing ComfyUI container functionality..."
        COMFYUI_TEST_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo Testing ComfyUI Docker functionality...",
            "# Test 1: Can we pull/run the container?",
            "timeout 60 docker run --rm ${{ needs.build-and-push.outputs.image-uri }} python --version > /tmp/test1.log 2>&1 && echo TEST1_OK || echo TEST1_FAIL",
            "# Test 2: Can we start ComfyUI briefly and then stop it?", 
            "timeout 30 docker run --rm -d --name comfyui-test -p 8188:8188 ${{ needs.build-and-push.outputs.image-uri }} > /tmp/container_id.txt || echo START_FAIL",
            "sleep 5",
            "if [ -f /tmp/container_id.txt ] && [ -s /tmp/container_id.txt ]; then",
            "  CONTAINER_ID=$(cat /tmp/container_id.txt)",
            "  # Check if container is running",
            "  if docker ps | grep -q $CONTAINER_ID; then",
            "    echo Container started successfully",
            "    # Test if port is accessible locally",
            "    timeout 10 curl -f http://localhost:8188/ > /dev/null 2>&1 && echo PORT_OK || echo PORT_TIMEOUT",
            "    # Clean stop the container",
            "    docker stop $CONTAINER_ID > /dev/null 2>&1",
            "    echo TEST2_OK",
            "  else",
            "    echo Container failed to stay running",
            "    echo TEST2_FAIL",
            "  fi",
            "else",
            "  echo Failed to start container",
            "  echo TEST2_FAIL",
            "fi",
            "# Test 3: Verify no containers are left running",
            "if [ $(docker ps -q | wc -l) -eq 0 ]; then",
            "  echo TEST3_OK",
            "else",
            "  echo WARNING: Containers still running",
            "  docker ps",
            "  echo TEST3_FAIL",
            "fi",
            "echo COMFYUI_TESTS_COMPLETE"
          ]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 90
        COMFYUI_TEST_STATUS=$(aws ssm get-command-invocation \
          --command-id $COMFYUI_TEST_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "ComfyUI Test Results:"
        echo "$COMFYUI_TEST_STATUS"
        
        if [[ "$COMFYUI_TEST_STATUS" != *"TEST1_OK"* ]]; then
          echo "âŒ ComfyUI container basic test failed"
          exit 1
        fi
        echo "âœ… ComfyUI container basic test passed"
        
        if [[ "$COMFYUI_TEST_STATUS" != *"TEST2_OK"* ]]; then
          echo "âŒ ComfyUI server startup test failed"
          exit 1
        fi
        echo "âœ… ComfyUI server startup test passed"
        
        if [[ "$COMFYUI_TEST_STATUS" != *"TEST3_OK"* ]]; then
          echo "âŒ Container cleanup test failed - containers may still be running"
          exit 1
        fi
        echo "âœ… Container cleanup test passed"
        
        # Verify system is clean for AMI creation
        echo "ðŸ§¹ Verifying system is clean for AMI creation..."
        CLEANUP_CHECK_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo Checking system cleanliness...",
            "# Check no containers running",
            "CONTAINERS=$(docker ps -q | wc -l)",
            "echo Running containers: $CONTAINERS",
            "# Check no temp files from our tests",
            "rm -f /tmp/test*.log /tmp/container_id.txt",
            "# Check system resources",
            "echo Memory usage: $(free -h | grep Mem:)",
            "echo Disk usage: $(df -h / | tail -1)",
            "echo CLEANUP_COMPLETE"
          ]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 15
        CLEANUP_STATUS=$(aws ssm get-command-invocation \
          --command-id $CLEANUP_CHECK_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "System Cleanup Results:"
        echo "$CLEANUP_STATUS"
        
        echo "ðŸŽ‰ All health checks passed! AMI is ready for creation."

    - name: Test network connectivity
      timeout-minutes: 3
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        PUBLIC_IP="${{ steps.launch-instance.outputs.public-ip }}"
        
        echo "ðŸŒ Testing network connectivity to instance..."
        echo "Public IP: $PUBLIC_IP"
        
        # Check security group allows outbound traffic
        echo "ðŸ”’ Checking security group configuration..."
        SG_ID=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'Reservations[0].Instances[0].SecurityGroups[0].GroupId' \
          --output text)
        
        echo "Security Group: $SG_ID"
        
        # Get security group rules
        aws ec2 describe-security-groups \
          --group-ids $SG_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'SecurityGroups[0].IpPermissions[*].[IpProtocol,FromPort,ToPort,IpRanges[0].CidrIp]' \
          --output table || true
        
        # Test basic connectivity from GitHub Actions runner
        echo "ðŸ“ Testing ICMP ping from GitHub Actions runner..."
        if ping -c 3 -W 5 $PUBLIC_IP; then
          echo "âœ… Ping successful from GitHub Actions"
        else
          echo "âš ï¸ Ping failed from GitHub Actions (this might be normal due to security groups)"
        fi
        
        # Test if we can reach common ports (this will fail but shows if security group is too restrictive)
        echo "ðŸ”Œ Testing port connectivity..."
        for port in 22 80 8188; do
          if timeout 5 nc -z $PUBLIC_IP $port; then
            echo "âœ… Port $port is accessible"
          else
            echo "âŒ Port $port is not accessible (expected for AMI building)"
          fi
        done
        
        echo "â„¹ï¸ Note: For security, the instance should NOT be accessible from the internet during AMI creation"
        echo "â„¹ï¸ When instances are launched from the AMI, proper security groups should be applied"

    - name: Create AMI
      id: create-ami
      timeout-minutes: 10
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        AMI_NAME="comfyui-multitenant-${ENVIRONMENT}-$(date +%Y%m%d-%H%M%S)"
        DOCKER_IMAGE="${{ needs.build-and-push.outputs.image-uri }}"
        
        echo "ðŸ“¸ Creating AMI from instance: $INSTANCE_ID"
        echo "ðŸ³ Docker image: $DOCKER_IMAGE"
        echo "ðŸ·ï¸ AMI name: $AMI_NAME"
        
        # Validate that we have a Docker image URI
        if [ -z "$DOCKER_IMAGE" ]; then
          echo "âŒ Error: Docker image URI is empty"
          exit 1
        fi
        
        # Stop the instance before creating AMI
        aws ec2 stop-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        aws ec2 wait instance-stopped --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        
        # Create AMI with proper tag format
        AMI_ID=$(aws ec2 create-image \
          --instance-id $INSTANCE_ID \
          --name "$AMI_NAME" \
          --description "ComfyUI Multi-Tenant AMI for $ENVIRONMENT environment with image $DOCKER_IMAGE" \
          --region ${{ env.AWS_REGION }} \
          --tag-specifications 'ResourceType=image,Tags=[{Key=Name,Value='"$AMI_NAME"'},{Key=Environment,Value='"$ENVIRONMENT"'},{Key=DockerImage,Value='"$DOCKER_IMAGE"'},{Key=Branch,Value=${{ github.ref_name }}}]' \
          --query 'ImageId' \
          --output text)
        
        echo "ami-id=$AMI_ID" >> $GITHUB_OUTPUT
        echo "âœ… AMI created: $AMI_ID"

    - name: Wait for AMI to be available
      timeout-minutes: 15
      run: |
        AMI_ID="${{ steps.create-ami.outputs.ami-id }}"
        echo "â³ Waiting for AMI to be available..."
        aws ec2 wait image-available --image-ids $AMI_ID --region ${{ env.AWS_REGION }}
        echo "âœ… AMI is available: $AMI_ID"

    - name: Cleanup builder instance
      if: always()
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        IAM_ROLE="${{ steps.launch-instance.outputs.iam-role }}"
        
        if [ -n "$INSTANCE_ID" ]; then
          echo "ðŸ§¹ Terminating builder instance: $INSTANCE_ID"
          
          # Force terminate the instance
          aws ec2 terminate-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }} || echo "âš ï¸ Instance may already be terminated"
          
          # Wait for termination to complete
          echo "â³ Waiting for instance termination..."
          aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }} || echo "âš ï¸ Timeout waiting for termination"
          
          echo "âœ… Builder instance cleanup completed"
        else
          echo "âš ï¸ No instance ID found to cleanup"
        fi
        
        # Clean up IAM role and instance profile
        if [ -n "$IAM_ROLE" ]; then
          echo "ðŸ§¹ Cleaning up IAM role: $IAM_ROLE"
          
          # Remove role from instance profile
          aws iam remove-role-from-instance-profile \
            --instance-profile-name "$IAM_ROLE" \
            --role-name "$IAM_ROLE" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ Role may already be removed"
          
          # Delete instance profile
          aws iam delete-instance-profile \
            --instance-profile-name "$IAM_ROLE" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ Instance profile may already be deleted"
          
          # Detach policies from role
          aws iam detach-role-policy \
            --role-name "$IAM_ROLE" \
            --policy-arn "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ S3 policy may already be detached"
          
          aws iam detach-role-policy \
            --role-name "$IAM_ROLE" \
            --policy-arn "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ SSM policy may already be detached"
          
          aws iam detach-role-policy \
            --role-name "$IAM_ROLE" \
            --policy-arn "arn:aws:iam::aws:policy/CloudWatchLogsFullAccess" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ CloudWatch policy may already be detached"
          
          # Delete role
          aws iam delete-role \
            --role-name "$IAM_ROLE" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸ Role may already be deleted"
          
          echo "âœ… IAM role cleanup completed"
        else
          echo "âš ï¸ No IAM role found to cleanup"
        fi

    - name: Monitor CloudWatch logs for debugging
      timeout-minutes: 5
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        echo "ðŸ“Š Checking CloudWatch logs for real-time debugging..."
        
        # Give CloudWatch agent time to start and send logs
        sleep 30
        
        # Check if AMI preparation logs are available in CloudWatch
        echo "ðŸ” Checking AMI preparation logs..."
        LOG_GROUPS=("/aws/ec2/comfyui/ami-preparation" "/aws/ec2/comfyui/user-data" "/aws/ec2/comfyui/docker")
        
        for LOG_GROUP in "${LOG_GROUPS[@]}"; do
          echo "ðŸ“‹ Checking log group: $LOG_GROUP"
          
          # List log streams for this instance
          STREAMS=$(aws logs describe-log-streams \
            --log-group-name "$LOG_GROUP" \
            --order-by LastEventTime \
            --descending \
            --max-items 5 \
            --region ${{ env.AWS_REGION }} \
            --query "logStreams[?contains(logStreamName, '$INSTANCE_ID')].logStreamName" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$STREAMS" ]; then
            echo "âœ… Found log streams in $LOG_GROUP: $STREAMS"
            
            # Get recent log events
            for STREAM in $STREAMS; do
              echo "ðŸ“„ Recent logs from $LOG_GROUP/$STREAM:"
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$STREAM" \
                --start-time $(($(date +%s) * 1000 - 300000)) \
                --region ${{ env.AWS_REGION }} \
                --query 'events[*].message' \
                --output text 2>/dev/null | tail -10 || echo "No recent events"
              echo "---"
            done
          else
            echo "âš ï¸ No log streams found for instance $INSTANCE_ID in $LOG_GROUP"
          fi
        done
        
        echo "ðŸ’¡ You can monitor real-time logs in AWS CloudWatch Console:"
        echo "   - AMI Preparation: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/%2Faws%2Fec2%2Fcomfyui%2Fami-preparation"
        echo "   - User Data: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/%2Faws%2Fec2%2Fcomfyui%2Fuser-data"
        echo "   - Docker: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/%2Faws%2Fec2%2Fcomfyui%2Fdocker"

    - name: Deployment Summary
      if: github.event_name != 'pull_request'
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        
        echo "## ðŸš€ ComfyUI Multi-Tenant Deployment Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ³ Docker Image" >> $GITHUB_STEP_SUMMARY
        echo "**Image URI:** \`${{ needs.build-and-push.outputs.image-uri }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Registry:** Amazon ECR Public" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“€ AMI" >> $GITHUB_STEP_SUMMARY
        echo "**AMI ID:** \`${{ steps.create-ami.outputs.ami-id }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Region:** \`${{ env.AWS_REGION }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŽ¯ Usage" >> $GITHUB_STEP_SUMMARY
        echo "Launch EC2 instances from this AMI to run the multi-tenant ComfyUI system." >> $GITHUB_STEP_SUMMARY
        echo "The management server will be available on port 80." >> $GITHUB_STEP_SUMMARY