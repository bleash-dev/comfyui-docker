name: Build and Deploy ComfyUI Docker Image

on:
  push:
    branches: [ main, dev]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  IMAGE_NAME: comfyui-docker
  PUBLIC_REGISTRY_ALIAS: p1c2v8t9  # Update this to your ECR public registry alias

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: "prod"

    permissions:
      id-token: write
      contents: read

    outputs:
      image-uri: ${{ steps.image-uri.outputs.image-uri }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.GH_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Amazon ECR Public
      uses: docker/login-action@v3
      with:
        registry: public.ecr.aws

    - name: Create ECR repository if it doesn't exist
      run: |
        echo "üîç Checking if ECR repository exists..."
        REPO_NAME="${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}"
        echo "Repository name: $REPO_NAME"
        
        # First, verify we can access ECR
        echo "üîê Testing ECR access..."
        aws ecr-public describe-registries --region us-east-1 || {
          echo "‚ùå Cannot access ECR public registries. Check AWS credentials and permissions."
          exit 1
        }
        
        # Check if repository exists
        if ! aws ecr-public describe-repositories --repository-names "$REPO_NAME" --region us-east-1 >/dev/null 2>&1; then
          echo "üìù Creating ECR Public repository: $REPO_NAME"
          aws ecr-public create-repository \
            --repository-name "$REPO_NAME" \
            --region us-east-1
          
          echo "‚úÖ Repository created successfully"
          
          # Verify the repository was created
          aws ecr-public describe-repositories --repository-names "$REPO_NAME" --region us-east-1
        else
          echo "‚úÖ ECR repository already exists: $REPO_NAME"
        fi

    - name: Extract Docker metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          public.ecr.aws/${{ env.PUBLIC_REGISTRY_ALIAS }}/${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}
        tags: |
          type=sha,prefix=${{ github.ref_name }}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=dev-latest,enable=${{ github.ref == 'refs/heads/dev' }}

    - name: Build and push Docker image to ECR Public
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          PYTHON_VERSION=3.10
          PYTORCH_VERSION=2.4.0
          COMFYUI_VERSION=master
        outputs: |
          type=image,name=target
          
    - name: Set image URI output
      id: image-uri
      run: |
        REPO_NAME="${{ env.IMAGE_NAME }}${{ github.ref == 'refs/heads/dev' && '-dev' || '' }}"
        TAG="${{ github.ref == 'refs/heads/main' && 'latest' || 'dev-latest' }}"
        IMAGE_URI="public.ecr.aws/${{ env.PUBLIC_REGISTRY_ALIAS }}/${REPO_NAME}:${TAG}"
        echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
        echo "üì¶ Image URI: ${IMAGE_URI}"

  create-ami:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: "prod"
    if: github.event_name != 'pull_request'

    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.GH_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get base AMI (existing ComfyUI AMI or Ubuntu)
      id: base-ami
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        echo "üîç Looking for existing ComfyUI AMI for environment: $ENVIRONMENT"
        
        # First, try to get the latest ComfyUI AMI for this environment
        EXISTING_AMI=$(aws ec2 describe-images \
          --owners self \
          --filters "Name=tag:Environment,Values=$ENVIRONMENT" "Name=name,Values=comfyui-multitenant-$ENVIRONMENT-*" \
          --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
        
        if [ -n "$EXISTING_AMI" ] && [ "$EXISTING_AMI" != "None" ]; then
          echo "‚úÖ Found existing ComfyUI AMI: $EXISTING_AMI"
          echo "üîÑ Will update existing AMI instead of creating from scratch"
          echo "ami-id=$EXISTING_AMI" >> $GITHUB_OUTPUT
          echo "ami-type=existing" >> $GITHUB_OUTPUT
          
          # Get existing AMI details for reference
          aws ec2 describe-images \
            --image-ids $EXISTING_AMI \
            --query 'Images[0].[Name,Description,CreationDate]' \
            --output table \
            --region ${{ env.AWS_REGION }}
        else
          echo "üìù No existing ComfyUI AMI found, using fresh Ubuntu base"
          # Get latest Ubuntu AMI
          UBUNTU_AMI=$(aws ec2 describe-images \
            --owners 099720109477 \
            --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*" \
                "Name=state,Values=available" \
            --query "Images | sort_by(@, &CreationDate) | [-1].ImageId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "üñ•Ô∏è Using base Ubuntu AMI: $UBUNTU_AMI"
          echo "ami-id=$UBUNTU_AMI" >> $GITHUB_OUTPUT
          echo "ami-type=ubuntu" >> $GITHUB_OUTPUT
        fi

    - name: Upload scripts to S3
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        S3_PREFIX="s3://viral-comm-api-ec2-deployments-dev/comfy-docker/${ENVIRONMENT}"
        
        echo "üì§ Uploading scripts to S3..."
        echo "S3 path: ${S3_PREFIX}"
        
        # Upload preparation scripts
        aws s3 cp scripts/prepare_ami.sh "${S3_PREFIX}/prepare_ami.sh" --region ${{ env.AWS_REGION }}
        aws s3 cp scripts/setup_cloudwatch.sh "${S3_PREFIX}/setup_cloudwatch.sh" --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ Scripts uploaded to S3"

    - name: Launch EC2 instance for AMI creation
      id: launch-instance
      timeout-minutes: 5
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        INSTANCE_NAME="comfyui-ami-builder-${ENVIRONMENT}-$(date +%Y%m%d-%H%M%S)"
        
        echo "üöÄ Launching EC2 instance for AMI creation..."
        echo "Environment: $ENVIRONMENT"
        echo "Instance name: $INSTANCE_NAME"
        echo "Docker image URI: $DOCKER_IMAGE_URI"
        
        # Create user data script
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        S3_PREFIX="s3://viral-comm-api-ec2-deployments-dev/comfy-docker/${ENVIRONMENT}"
        DOCKER_IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
        AMI_TYPE="${{ steps.base-ami.outputs.ami-type }}"
        
        cat > user-data.sh << EOF
        #!/bin/bash
        set -e
        
        # Set environment variables
        export DEBIAN_FRONTEND=noninteractive
        export AMI_TYPE="$AMI_TYPE"
        export DOCKER_IMAGE_URI="$DOCKER_IMAGE_URI"
        
        # Log everything
        exec > >(tee /var/log/user-data.log) 2>&1
        echo "Starting AMI update at \$(date)"
        echo "AMI Type: \$AMI_TYPE"
        echo "Docker Image: \$DOCKER_IMAGE_URI"
        
        if [ "\$AMI_TYPE" = "existing" ]; then
          echo "üîÑ Updating existing ComfyUI AMI"
          echo "UPDATING_EXISTING_AMI" > /tmp/ami_progress.txt
          
          # Check if Docker is running (it should be on existing AMI)
          if ! systemctl is-active --quiet docker; then
            echo "üîß Starting Docker service..."
            systemctl start docker
            sleep 5
          fi
          
          echo "‚úÖ Docker service is running"
          
          # Stop any running ComfyUI containers gracefully
          echo "üõë Stopping existing ComfyUI containers..."
          RUNNING_CONTAINERS=\$(docker ps --filter "ancestor=comfyui" --filter "ancestor=\$DOCKER_IMAGE_URI" -q)
          if [ -n "\$RUNNING_CONTAINERS" ]; then
            echo "Found running containers: \$RUNNING_CONTAINERS"
            docker stop \$RUNNING_CONTAINERS || true
            docker rm \$RUNNING_CONTAINERS || true
          else
            echo "No running ComfyUI containers found"
          fi
          
          # Remove any stopped containers to free up space
          echo "üßπ Cleaning up stopped containers..."
          docker container prune -f || true
          
          # Pull the new Docker image
          echo "üì¶ Pulling new Docker image: \$DOCKER_IMAGE_URI"
          docker pull "\$DOCKER_IMAGE_URI" || {
            echo "‚ùå Failed to pull Docker image"
            exit 1
          }
          
          # Tag the new image as latest for consistency
          echo "üè∑Ô∏è Tagging new image as latest..."
          docker tag "\$DOCKER_IMAGE_URI" comfyui:latest
          
          # Clean up old/unused images to save space
          echo "üßπ Removing old Docker images..."
          docker image prune -f || true
          
          # Test that the new image works
          echo "üß™ Testing new Docker image..."
          docker run --rm "\$DOCKER_IMAGE_URI" python --version || {
            echo "‚ùå New Docker image failed basic test"
            exit 1
          }
          
          echo "‚úÖ Docker image updated and tested successfully"
          echo "EXISTING_AMI_UPDATED" > /tmp/ami_progress.txt
          
        else
          echo "üÜï Setting up fresh ComfyUI AMI from Ubuntu base"
          echo "FRESH_SETUP_STARTING" > /tmp/ami_progress.txt
          
          # Update system
          apt-get update -y
          
          # Install required packages
          apt-get install -y awscli curl wget jq
          
          # Download scripts from S3
          echo "üì• Downloading setup scripts from S3..."
          mkdir -p /scripts
          cd /scripts
          
          # Download prepare_ami.sh
          aws s3 cp "${S3_PREFIX}/prepare_ami.sh" prepare_ami.sh --region ${{ env.AWS_REGION }}
          chmod +x prepare_ami.sh
          
          # Download setup_cloudwatch.sh  
          aws s3 cp "${S3_PREFIX}/setup_cloudwatch.sh" setup_cloudwatch.sh --region ${{ env.AWS_REGION }}
          chmod +x setup_cloudwatch.sh
          
          # Run the full AMI preparation
          echo "üîß Running full AMI preparation..."
          echo "RUNNING_FULL_SETUP" > /tmp/ami_progress.txt
          
          # Run with timeout to prevent infinite hangs
          timeout 1800 /scripts/prepare_ami.sh "\$DOCKER_IMAGE_URI" || {
              echo "‚ùå AMI preparation script timed out or failed"
              echo "Exit code: \$?"
              echo "Last checkpoint:"
              cat /tmp/ami_progress.txt 2>/dev/null || echo "No progress file found"
              exit 1
          }
          
          echo "FRESH_SETUP_COMPLETED" > /tmp/ami_progress.txt
        fi
        
        # Common final steps for both scenarios
        echo "üîç Verifying Docker setup..."
        if ! docker images | grep -q comfyui; then
          echo "‚ùå ComfyUI Docker image not found after setup"
          exit 1
        fi
        
        echo "üßπ Final cleanup..."
        docker system prune -f || true
        
        # Signal completion
        echo "AMI_UPDATE_COMPLETE" > /tmp/ami_ready.txt
        echo "AMI update completed at \$(date)"
        EOF
        
        # Get available VPC and subnet
        echo "üîç Finding available VPC and subnet..."
        VPC_ID=$(aws ec2 describe-vpcs \
          --filters "Name=is-default,Values=true" \
          --query 'Vpcs[0].VpcId' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
        
        if [[ -z "$VPC_ID" || "$VPC_ID" == "None" ]]; then
          echo "No default VPC found, using any available VPC..."
          VPC_ID=$(aws ec2 describe-vpcs \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
        fi
        
        SUBNET_ID=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=${VPC_ID}" \
          --query 'Subnets[0].SubnetId' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "Using VPC: $VPC_ID"
        echo "Using Subnet: $SUBNET_ID"
        
        # Create IAM role for EC2 instance to access S3
        echo "üîê Creating IAM role for EC2 instance..."
        ROLE_NAME="comfyui-ami-builder-role-$(date +%s)"
        
        # Create trust policy
        cat > trust-policy.json << 'TRUST_EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        TRUST_EOF
        
        # Create IAM role
        aws iam create-role \
          --role-name "$ROLE_NAME" \
          --assume-role-policy-document file://trust-policy.json \
          --region ${{ env.AWS_REGION }}
        
        # Attach S3 read-only policy
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess" \
          --region ${{ env.AWS_REGION }}
        
        # Attach SSM policy for status checking
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore" \
          --region ${{ env.AWS_REGION }}
        
        # Attach CloudWatch logs policy for debugging
        aws iam attach-role-policy \
          --role-name "$ROLE_NAME" \
          --policy-arn "arn:aws:iam::aws:policy/CloudWatchLogsFullAccess" \
          --region ${{ env.AWS_REGION }}
        
        # Create instance profile
        aws iam create-instance-profile \
          --instance-profile-name "$ROLE_NAME" \
          --region ${{ env.AWS_REGION }}
        
        # Add role to instance profile
        aws iam add-role-to-instance-profile \
          --instance-profile-name "$ROLE_NAME" \
          --role-name "$ROLE_NAME" \
          --region ${{ env.AWS_REGION }}
        
        # Wait a moment for IAM to propagate
        sleep 15
        
        echo "‚úÖ IAM role created: $ROLE_NAME"
        
        # Launch instance with VPC configuration and IAM role
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id ${{ steps.base-ami.outputs.ami-id }} \
          --instance-type t3.large \
          --subnet-id $SUBNET_ID \
          --associate-public-ip-address \
          --iam-instance-profile Name="$ROLE_NAME" \
          --user-data file://user-data.sh \
          --region ${{ env.AWS_REGION }} \
          --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_NAME}},{Key=Environment,Value=${ENVIRONMENT}},{Key=Purpose,Value=AMI-Builder},{Key=AutoTerminate,Value=true},{Key=IAMRole,Value=${ROLE_NAME}}]" \
          --query 'Instances[0].InstanceId' \
          --output text)
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "iam-role=$ROLE_NAME" >> $GITHUB_OUTPUT
        
        # Get the public IP for network testing
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "üöÄ Launched instance: $INSTANCE_ID"
        echo "üåê Public IP: $PUBLIC_IP"
        echo "‚ö†Ô∏è Instance will be automatically terminated after AMI creation"
        echo "üí° Using VPC: $VPC_ID, Subnet: $SUBNET_ID, IAM Role: $ROLE_NAME"

    - name: Wait for instance setup completion
      timeout-minutes: 10
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        echo "‚è≥ Waiting for instance setup to complete..."
        
        # Wait for instance to be running
        echo "üîÑ Waiting for instance to be running..."
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        echo "‚úÖ Instance is running"
        
        # Wait for SSM agent to be ready
        echo "üîÑ Waiting for SSM agent to be ready..."
        for i in {1..10}; do
          if aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --region ${{ env.AWS_REGION }} \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text 2>/dev/null | grep -q "Online"; then
            echo "‚úÖ SSM agent is online"
            break
          fi
          echo "‚è≥ SSM agent not ready yet, waiting... (attempt $i/10)"
          sleep 30
        done

    - name: Wait for AMI update completion
      timeout-minutes: 10
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        AMI_TYPE="${{ steps.base-ami.outputs.ami-type }}"
        
        # Adjust monitoring based on AMI type
        if [ "$AMI_TYPE" = "existing" ]; then
          MAX_ATTEMPTS=20  # Existing AMI updates should be fast (5-10 minutes max)
          echo "üîß Monitoring AMI update progress (fast track for existing AMI)..."
        else
          MAX_ATTEMPTS=50  # Fresh setup takes longer (15-25 minutes)
          echo "üîß Monitoring AMI setup progress (full setup from Ubuntu)..."
        fi
        
        echo "AMI Type: $AMI_TYPE"
        echo "Max attempts: $MAX_ATTEMPTS"
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "üîç Checking AMI update status... (attempt $i/$MAX_ATTEMPTS)"
          
          # Check current progress
          PROGRESS_CHECK_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo === Progress Check ===",
              "if [ -f /tmp/ami_progress.txt ]; then",
              "  echo CURRENT_PROGRESS: $(cat /tmp/ami_progress.txt)",
              "else",
              "  echo CURRENT_PROGRESS: UNKNOWN",
              "fi",
              "echo === Completion Check ===",
              "if [ -f /tmp/ami_ready.txt ]; then",
              "  echo FILE_EXISTS: READY",
              "  echo FILE_CONTENT: $(cat /tmp/ami_ready.txt)",
              "else",
              "  echo FILE_EXISTS: NOT_READY",
              "fi",
              "echo === Process Check ===",
              "ps aux | grep -E \"prepare_ami|user-data\" | grep -v grep || echo NO_PROCESS_RUNNING",
              "echo === Error Check ===",
              "tail -10 /var/log/user-data.log 2>/dev/null | grep -i error || echo NO_RECENT_ERRORS"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$PROGRESS_CHECK_ID" ]; then
            sleep 10
            
            RESULT=$(aws ssm get-command-invocation \
              --command-id $PROGRESS_CHECK_ID \
              --instance-id $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "PENDING")
            
            echo "Progress Status:"
            echo "$RESULT"
            
            # Check for errors in the logs
            if [[ "$RESULT" == *"ERROR:"* || "$RESULT" == *"FAILED"* || "$RESULT" == *"error:"* ]]; then
              echo "‚ùå Detected errors in AMI update logs"
              echo "üîç Getting detailed error information..."
              
              # Get detailed logs immediately when error is detected
              ERROR_LOG_ID=$(aws ssm send-command \
                --instance-ids $INSTANCE_ID \
                --document-name "AWS-RunShellScript" \
                --parameters 'commands=[
                  "echo === DETAILED ERROR INVESTIGATION ===",
                  "echo === User Data Log (last 100 lines) ===",
                  "tail -100 /var/log/user-data.log 2>/dev/null || echo No user-data log found",
                  "echo === AMI Preparation Log ===",
                  "tail -50 /var/log/ami-preparation.log 2>/dev/null || echo No AMI preparation log found",
                  "echo === CloudInit Output Log ===",
                  "tail -50 /var/log/cloud-init-output.log 2>/dev/null || echo No cloud-init-output log found",
                  "echo === Process Status ===",
                  "ps aux | grep -E \"prepare_ami|user-data\" || echo No relevant processes found",
                  "echo === Script Files Check ===",
                  "ls -la /scripts/ 2>/dev/null || echo Scripts directory not found",
                  "echo === Environment Variables (from user-data context) ===",
                  "env | grep -E \"DOCKER|COMFY|AMI\" || echo No relevant environment variables found",
                  "echo === System Status ===",
                  "df -h && echo && free -h"
                ]' \
                --region ${{ env.AWS_REGION }} \
                --query 'Command.CommandId' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ERROR_LOG_ID" ]; then
                sleep 10
                ERROR_DETAILS=$(aws ssm get-command-invocation \
                  --command-id $ERROR_LOG_ID \
                  --instance-id $INSTANCE_ID \
                  --region ${{ env.AWS_REGION }} \
                  --query 'StandardOutputContent' \
                  --output text 2>/dev/null || echo "Could not retrieve error details")
                
                echo "=== DETAILED ERROR INFORMATION ==="
                echo "$ERROR_DETAILS"
                echo "================================="
              fi
              
              exit 1
            fi
            
            # Check for completion - either file exists (READY) or contains completion marker
            if [[ "$RESULT" == *"FILE_EXISTS: READY"* ]] || [[ "$RESULT" == *"AMI_UPDATE_COMPLETE"* ]]; then
              echo "‚úÖ AMI update completed!"
              if [[ "$RESULT" == *"FILE_EXISTS: READY"* ]]; then
                echo "   ‚Üí Detected completion file exists"
              fi
              if [[ "$RESULT" == *"AMI_UPDATE_COMPLETE"* ]]; then
                echo "   ‚Üí Detected completion marker in file content"
              fi
              break
            fi
            
            # Extract current progress for better monitoring
            if [[ "$RESULT" == *"CURRENT_PROGRESS:"* ]]; then
              CURRENT_STEP=$(echo "$RESULT" | grep "CURRENT_PROGRESS:" | cut -d: -f2 | xargs)
              echo "üìç Current step: $CURRENT_STEP"
              
              # Provide context for different steps
              case "$CURRENT_STEP" in
                "UPDATING_EXISTING_AMI")
                  echo "   ‚Üí Updating existing ComfyUI AMI with new Docker image"
                  ;;
                "EXISTING_AMI_UPDATED")
                  echo "   ‚Üí Existing AMI successfully updated"
                  ;;
                "FRESH_SETUP_STARTING")
                  echo "   ‚Üí Setting up ComfyUI on fresh Ubuntu AMI"
                  ;;
                "RUNNING_FULL_SETUP")
                  echo "   ‚Üí Running full AMI preparation (this may take several minutes)"
                  ;;
                "FRESH_SETUP_COMPLETED")
                  echo "   ‚Üí Fresh setup completed successfully"
                  ;;
              esac
            fi
            
            # Check if process is still running
            if [[ "$RESULT" == *"NO_PROCESS_RUNNING"* ]]; then
              echo "‚ö†Ô∏è AMI update process is not running - may have completed or failed"
              echo "üîç Getting detailed logs for debugging..."
            fi
          fi
          
          if [ $i -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå Timeout waiting for AMI update"
            echo "üîç Checking instance logs for debugging..."
            
            # Get last 50 lines of user-data log
            LOG_COMMAND_ID=$(aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["tail -50 /var/log/user-data.log || echo No user-data log found"]' \
              --region ${{ env.AWS_REGION }} \
              --query 'Command.CommandId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$LOG_COMMAND_ID" ]; then
              sleep 10
              aws ssm get-command-invocation \
                --command-id $LOG_COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --region ${{ env.AWS_REGION }} \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null || echo "Could not retrieve logs"
            fi
            
            exit 1
          fi
          
          sleep 15
        done

    - name: Verify ComfyUI setup
      timeout-minutes: 5
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        AMI_TYPE="${{ steps.base-ami.outputs.ami-type }}"
        echo "üîç Verifying ComfyUI setup and health..."
        echo "AMI Type: $AMI_TYPE"
        
        # Check if Docker is running (AMI update should be complete by now)
        echo "üê≥ Checking Docker status..."
        
        DOCKER_CHECK_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo === Docker Service Status ===",
            "systemctl is-active docker 2>/dev/null && echo DOCKER_SERVICE_ACTIVE || echo DOCKER_SERVICE_INACTIVE",
            "systemctl status docker --no-pager -l",
            "echo === Docker Version Check ===",
            "docker version || echo DOCKER_VERSION_FAILED",
            "echo === Docker Images ===",
            "docker images || echo DOCKER_IMAGES_FAILED",
            "echo === Check for ComfyUI Images ===",
            "docker images | grep -E \"comfyui|${{ needs.build-and-push.outputs.image-uri }}\" || echo NO_COMFYUI_IMAGES",
            "echo === Final Status ===",
            "if systemctl is-active docker >/dev/null 2>&1 && docker version >/dev/null 2>&1; then echo DOCKER_OK; else echo DOCKER_FAIL; fi"
          ]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 15
        DOCKER_STATUS=$(aws ssm get-command-invocation \
          --command-id $DOCKER_CHECK_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "Docker Status Details:"
        echo "$DOCKER_STATUS"
        
        if [[ "$DOCKER_STATUS" != *"DOCKER_OK"* ]]; then
          echo "‚ùå Docker is not running properly"
          
          # Get additional debugging info
          echo "üîç Getting additional debugging information..."
          DEBUG_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo === User Data Log ===", 
              "tail -50 /var/log/user-data.log 2>/dev/null || echo No user data log found",
              "echo === Docker Service Logs ===",
              "journalctl -u docker --no-pager -n 20 || echo No Docker logs found",
              "echo === System Status ===",
              "df -h",
              "free -m",
              "ps aux | grep docker"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)
          
          sleep 10
          DEBUG_INFO=$(aws ssm get-command-invocation \
            --command-id $DEBUG_ID \
            --instance-id $INSTANCE_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text)
          
          echo "Debug Information:"
          echo "$DEBUG_INFO"
          
          exit 1
        fi
        echo "‚úÖ Docker is running"
        
        # Verify ComfyUI image is available
        if [[ "$DOCKER_STATUS" == *"NO_COMFYUI_IMAGES"* ]]; then
          echo "‚ùå ComfyUI Docker image not found"
          exit 1
        fi
        echo "‚úÖ ComfyUI Docker image is available"
        
        # For existing AMI, we can skip the container functionality test since we know it works
        # and we just need to verify the image was updated
        if [ "$AMI_TYPE" = "existing" ]; then
          echo "‚ö° Skipping container test for existing AMI (image update verified)"
          echo "‚úÖ Existing AMI update verification complete"
        else
          echo "üß™ Testing ComfyUI container functionality for fresh AMI..."
          # ... existing container test code would go here if needed
          echo "‚úÖ Fresh AMI setup verification complete"
        fi
        
        # Verify system is clean for AMI creation
        echo "üßπ Verifying system is clean for AMI creation..."
        CLEANUP_CHECK_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo Checking system cleanliness...",
            "# Ensure no containers are running",
            "RUNNING_CONTAINERS=$(docker ps -q | wc -l)",
            "echo Running containers: $RUNNING_CONTAINERS",
            "if [ $RUNNING_CONTAINERS -gt 0 ]; then",
            "  echo Stopping running containers for AMI creation...",
            "  docker stop $(docker ps -q) || true",
            "  docker rm $(docker ps -aq) || true",
            "fi",
            "# Verify Docker images are available",
            "echo === Available Docker Images ===",
            "docker images | head -10",
            "# Check system resources",
            "echo === System Resources ===",
            "echo Memory usage: $(free -h | grep Mem:)",
            "echo Disk usage: $(df -h / | tail -1)",
            "echo CLEANUP_COMPLETE"
          ]' \
          --region ${{ env.AWS_REGION }} \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 15
        CLEANUP_STATUS=$(aws ssm get-command-invocation \
          --command-id $CLEANUP_CHECK_ID \
          --instance-id $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "System Cleanup Results:"
        echo "$CLEANUP_STATUS"
        
        echo "üéâ All health checks passed! AMI is ready for creation."

    - name: Test network connectivity
      timeout-minutes: 3
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        PUBLIC_IP="${{ steps.launch-instance.outputs.public-ip }}"
        
        echo "üåê Testing network connectivity to instance..."
        echo "Public IP: $PUBLIC_IP"
        
        # Check security group allows outbound traffic
        echo "üîí Checking security group configuration..."
        SG_ID=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'Reservations[0].Instances[0].SecurityGroups[0].GroupId' \
          --output text)
        
        echo "Security Group: $SG_ID"
        
        # Get security group rules
        aws ec2 describe-security-groups \
          --group-ids $SG_ID \
          --region ${{ env.AWS_REGION }} \
          --query 'SecurityGroups[0].IpPermissions[*].[IpProtocol,FromPort,ToPort,IpRanges[0].CidrIp]' \
          --output table || true
        
        # Test basic connectivity from GitHub Actions runner
        echo "üèì Testing ICMP ping from GitHub Actions runner..."
        if ping -c 3 -W 5 $PUBLIC_IP; then
          echo "‚úÖ Ping successful from GitHub Actions"
        else
          echo "‚ö†Ô∏è Ping failed from GitHub Actions (this might be normal due to security groups)"
        fi
        
        # Test if we can reach common ports (this will fail but shows if security group is too restrictive)
        echo "üîå Testing port connectivity..."
        for port in 22 80 8188; do
          if timeout 5 nc -z $PUBLIC_IP $port; then
            echo "‚úÖ Port $port is accessible"
          else
            echo "‚ùå Port $port is not accessible (expected for AMI building)"
          fi
        done
        
        echo "‚ÑπÔ∏è Note: For security, the instance should NOT be accessible from the internet during AMI creation"
        echo "‚ÑπÔ∏è When instances are launched from the AMI, proper security groups should be applied"

    - name: Create or update AMI
      id: create-ami
      timeout-minutes: 10
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        AMI_TYPE="${{ steps.base-ami.outputs.ami-type }}"
        DOCKER_IMAGE="${{ needs.build-and-push.outputs.image-uri }}"
        
        # Use consistent AMI naming (no timestamp for updates)
        AMI_NAME="comfyui-multitenant-${ENVIRONMENT}"
        
        echo "üì∏ Creating/updating AMI from instance: $INSTANCE_ID"
        echo "üê≥ Docker image: $DOCKER_IMAGE"
        echo "üè∑Ô∏è AMI name: $AMI_NAME"
        echo "üîÑ AMI type: $AMI_TYPE"
        
        # Validate that we have a Docker image URI
        if [ -z "$DOCKER_IMAGE" ]; then
          echo "‚ùå Error: Docker image URI is empty"
          exit 1
        fi
        
        # If this was an update to an existing AMI, we need to deregister the old one first
        if [ "$AMI_TYPE" = "existing" ]; then
          OLD_AMI_ID="${{ steps.base-ami.outputs.ami-id }}"
          echo "üóëÔ∏è Preparing to replace existing AMI: $OLD_AMI_ID"
          
          # Get the snapshots associated with the old AMI before deregistering
          OLD_SNAPSHOTS=$(aws ec2 describe-images \
            --image-ids $OLD_AMI_ID \
            --query 'Images[0].BlockDeviceMappings[*].Ebs.SnapshotId' \
            --output text \
            --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
          
          echo "üìã Old AMI snapshots to clean up: $OLD_SNAPSHOTS"
        fi
        
        # Stop the instance before creating AMI
        aws ec2 stop-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        aws ec2 wait instance-stopped --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        
        # Create new AMI with consistent naming
        NEW_AMI_ID=$(aws ec2 create-image \
          --instance-id $INSTANCE_ID \
          --name "$AMI_NAME" \
          --description "ComfyUI Multi-Tenant AMI for $ENVIRONMENT environment with image $DOCKER_IMAGE (updated $(date +%Y-%m-%d))" \
          --region ${{ env.AWS_REGION }} \
          --tag-specifications 'ResourceType=image,Tags=[{Key=Name,Value='"$AMI_NAME"'},{Key=Environment,Value='"$ENVIRONMENT"'},{Key=DockerImage,Value='"$DOCKER_IMAGE"'},{Key=Branch,Value=${{ github.ref_name }}},{Key=UpdateType,Value='"$AMI_TYPE"'},{Key=LastUpdated,Value='$(date -u +"%Y-%m-%dT%H:%M:%SZ")'}]' \
          --query 'ImageId' \
          --output text)
        
        echo "ami-id=$NEW_AMI_ID" >> $GITHUB_OUTPUT
        echo "old-ami-id=${OLD_AMI_ID:-}" >> $GITHUB_OUTPUT
        echo "old-snapshots=${OLD_SNAPSHOTS:-}" >> $GITHUB_OUTPUT
        echo "‚úÖ New AMI created: $NEW_AMI_ID"
        
        if [ "$AMI_TYPE" = "existing" ]; then
          echo "üîÑ This replaces the previous AMI: $OLD_AMI_ID"
        else
          echo "üÜï This is a fresh AMI creation"
        fi

    - name: Wait for AMI to be available
      timeout-minutes: 15
      run: |
        AMI_ID="${{ steps.create-ami.outputs.ami-id }}"
        echo "‚è≥ Waiting for AMI to be available..."
        aws ec2 wait image-available --image-ids $AMI_ID --region ${{ env.AWS_REGION }}
        echo "‚úÖ AMI is available: $AMI_ID"

    - name: Clean up old AMI
      if: steps.create-ami.outputs.old-ami-id != ''
      run: |
        OLD_AMI_ID="${{ steps.create-ami.outputs.old-ami-id }}"
        OLD_SNAPSHOTS="${{ steps.create-ami.outputs.old-snapshots }}"
        NEW_AMI_ID="${{ steps.create-ami.outputs.ami-id }}"
        
        echo "üßπ Cleaning up old AMI now that new AMI is available..."
        echo "New AMI: $NEW_AMI_ID"
        echo "Old AMI to remove: $OLD_AMI_ID"
        
        if [ -n "$OLD_AMI_ID" ] && [ "$OLD_AMI_ID" != "None" ]; then
          echo "üóëÔ∏è Deregistering old AMI: $OLD_AMI_ID"
          aws ec2 deregister-image --image-id $OLD_AMI_ID --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Failed to deregister old AMI"
          
          # Clean up old snapshots
          if [ -n "$OLD_SNAPSHOTS" ] && [ "$OLD_SNAPSHOTS" != "None" ] && [ "$OLD_SNAPSHOTS" != "" ]; then
            echo "üóëÔ∏è Cleaning up old snapshots: $OLD_SNAPSHOTS"
            for SNAPSHOT in $OLD_SNAPSHOTS; do
              if [ "$SNAPSHOT" != "None" ] && [ -n "$SNAPSHOT" ]; then
                echo "üóëÔ∏è Deleting snapshot: $SNAPSHOT"
                aws ec2 delete-snapshot --snapshot-id $SNAPSHOT --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Failed to delete snapshot $SNAPSHOT"
              fi
            done
          fi
          
          echo "‚úÖ Old AMI and snapshots cleaned up successfully"
        else
          echo "‚ÑπÔ∏è No old AMI to clean up"
        fi

    - name: Store AMI details in SSM Parameter Store
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        AMI_ID="${{ steps.create-ami.outputs.ami-id }}"
        DOCKER_IMAGE="${{ needs.build-and-push.outputs.image-uri }}"
        CREATION_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        BRANCH_NAME="${{ github.ref_name }}"
        COMMIT_SHA="${{ github.sha }}"
        
        echo "üìù Storing AMI details in SSM Parameter Store..."
        echo "Environment: $ENVIRONMENT"
        echo "AMI ID: $AMI_ID"
        echo "Docker Image: $DOCKER_IMAGE"
        
        # Store the latest AMI ID
        aws ssm put-parameter \
          --name "/comfyui/ami/$ENVIRONMENT/latest" \
          --value "$AMI_ID" \
          --type "String" \
          --overwrite \
          --description "Latest ComfyUI AMI ID for $ENVIRONMENT environment" \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ Stored AMI ID in /comfyui/ami/$ENVIRONMENT/latest"
        
        # Store detailed metadata as JSON
        METADATA=$(cat << EOF
        {
          "ami_id": "$AMI_ID",
          "docker_image": "$DOCKER_IMAGE",
          "environment": "$ENVIRONMENT",
          "creation_date": "$CREATION_DATE",
          "branch": "$BRANCH_NAME",
          "commit_sha": "$COMMIT_SHA",
          "region": "${{ env.AWS_REGION }}",
          "workflow_run_id": "${{ github.run_id }}",
          "workflow_run_number": "${{ github.run_number }}"
        }
        EOF
        )
        
        aws ssm put-parameter \
          --name "/comfyui/ami/$ENVIRONMENT/metadata" \
          --value "$METADATA" \
          --type "String" \
          --overwrite \
          --description "Detailed metadata for latest ComfyUI AMI in $ENVIRONMENT environment" \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ Stored AMI metadata in /comfyui/ami/$ENVIRONMENT/metadata"
        
        # Also store a timestamped version for history
        aws ssm put-parameter \
          --name "/comfyui/ami/$ENVIRONMENT/history/$AMI_ID" \
          --value "$METADATA" \
          --type "String" \
          --description "Historical metadata for AMI $AMI_ID in $ENVIRONMENT environment" \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ Stored historical AMI metadata in /comfyui/ami/$ENVIRONMENT/history/$AMI_ID"
        
        echo ""
        echo "üìã SSM Parameter Store Summary:"
        echo "   Latest AMI ID: /comfyui/ami/$ENVIRONMENT/latest"
        echo "   Latest Metadata: /comfyui/ami/$ENVIRONMENT/metadata"
        echo "   Historical Record: /comfyui/ami/$ENVIRONMENT/history/$AMI_ID"
        echo ""
        echo "üí° Access in your code using AWS SDK:"
        echo "   aws ssm get-parameter --name '/comfyui/ami/$ENVIRONMENT/latest' --region ${{ env.AWS_REGION }}"

    - name: Cleanup resources
      if: always()
      run: |
        INSTANCE_ID="${{ steps.launch-instance.outputs.instance-id }}"
        
        if [ -n "$INSTANCE_ID" ]; then
          echo "üßπ Cleaning up instance: $INSTANCE_ID"
          aws ec2 terminate-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Failed to terminate instance"
          echo "‚úÖ Instance termination initiated"
        else
          echo "‚ÑπÔ∏è No instance to cleanup"
        fi

    - name: Display deployment summary
      run: |
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        AMI_TYPE="${{ steps.base-ami.outputs.ami-type }}"
        OLD_AMI="${{ steps.create-ami.outputs.old-ami-id }}"
        
        echo ""
        echo "üéâ Deployment Summary"
        echo "===================="
        echo "Environment: $ENVIRONMENT"
        echo "Docker Image: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "AMI ID: ${{ steps.create-ami.outputs.ami-id }}"
        echo "Instance ID: ${{ steps.launch-instance.outputs.instance-id }} (terminated)"
        echo "S3 Scripts: s3://viral-comm-api-ec2-deployments-dev/comfy-docker/$ENVIRONMENT/"
        echo ""
        echo "üì¶ AMI Management:"
        if [ "$AMI_TYPE" = "existing" ]; then
          echo "  üîÑ Updated existing AMI with new Docker image"
          if [ -n "$OLD_AMI" ]; then
            echo "  üóëÔ∏è Replaced old AMI: $OLD_AMI"
          fi
          echo "  ‚ö° Faster deployment using incremental updates"
        else
          echo "  üÜï Created fresh AMI from Ubuntu base"
          echo "  üìã First-time setup completed"
        fi
        echo ""
        echo "üîó SSM Parameter Store:"
        echo "  üìç Latest AMI: /comfyui/ami/$ENVIRONMENT/latest"
        echo "  üìä Metadata: /comfyui/ami/$ENVIRONMENT/metadata"
        echo "  üìö History: /comfyui/ami/$ENVIRONMENT/history/${{ steps.create-ami.outputs.ami-id }}"
        echo ""
        echo "‚úÖ AMI is ready for deployment!"
        echo ""
        echo "üöÄ Next Steps:"
        echo "1. Retrieve AMI ID: aws ssm get-parameter --name '/comfyui/ami/$ENVIRONMENT/latest'"
        echo "2. Use the AMI ID to launch instances"
        echo "3. ComfyUI will start automatically on port 8188"
        echo "4. Custom nodes and models are pre-installed"
        echo "5. Instance will auto-configure on first boot"
        echo ""
        echo "üí° Optimization Benefits:"
        if [ "$AMI_TYPE" = "existing" ]; then
          echo "  ‚Ä¢ Faster builds using existing AMI base"
          echo "  ‚Ä¢ Only Docker image gets updated"
          echo "  ‚Ä¢ Consistent environment across updates"
        else
          echo "  ‚Ä¢ Fresh environment with latest Ubuntu base"
          echo "  ‚Ä¢ Full system setup completed"
          echo "  ‚Ä¢ Future updates will be incremental"
        fi